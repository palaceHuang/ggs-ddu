[toc]

# JS 内存机制

## JS 数据存储机制

### 内存空间

在 JavaScript 的执行过程中，主要有三种类型内存空间，分别是代码空间，栈空间和堆空间

1. 代码空间
   用来存放可执行代码
2. 栈空间
   一块连续的内存区域，容量较小，读取速度快，被设计为后进先出
3. 堆空间
   不连续的内存区域，容量较大，用于储存大数据，读取速度慢

### 数据类型

JS 中的八种数据类型，除了 Object 都是基本数据类型

### 栈空间和堆空间

栈空间就是 JavaScript 中的调用栈，是用来储存执行上下文，以及存储执行上下文中的一些基本类型中的小数据

栈空间部分组成

1. fn 函数执行上下文
   变量环境  
   词法环境
2. 全局执行上下文
   变量环境  
   词法环境

变量环境：存放 var 声明和函数声明的变量空间，编译时就能确定，不受块级作用域影响  
词法环境：存放 let 和 const 声明的变量空间，编译时不能完全确定，受块级作用域影响

而堆空间，则是用来储存大数据如引用类型，然后把它们的引用地址保存在栈空间的变量中，所以多了这一道中转，JavaScript 对堆空间数据的读取自然会比栈空间数据的要慢

通常情况下，栈空间都不会设置太大，这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了的话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率

### 闭包

内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包

闭包中的数据会组成一个对象，然后保存在堆空间中

可以利用开发者工具查看闭包情况，其中括号中的名称就是产生闭包的函数名。一般我们会认为闭包是返回的内部函数引用的变量集合，但闭包有例外。

如果函数存在闭包，其所有内部函数都会拥有一个指向这个闭包的引用，即所有内部函数会共享一个闭包，只要任意内部函数有引用外部函数中声明的变量，这个变量就会被纳入闭包内，而且最内部的函数会持有所有外部的闭包。

### 堆栈存放的数据类型

调用栈中的引用类型放在堆中

**数字**
V8 把数字分成两种类型：smi 和 heapNumber
smi 的范围是-2 的 31 次方到 2 的 31 次方-1 的整数，在栈中直接存值；除了 smi，其余数字类型都是 heapNumber，需要另外开辟堆空间进行储存，变量保存其引用

**更基本的基本类型**
V8 还定义了一种 oddball 类型，属于 oddball 类型的有 null、undefined、true 和 false

# JS 运行机制

## 浏览器包括哪些进程

1. Browser 进程  
   浏览器的主进程，负责协调、主控，只有一个。作用有：
   - 负责浏览器界面显示，与用户交互
   - 负责各个页面的管理，创建和销毁其它进程
   - 将 Renderer 进程得到的内存中的 bitmap，绘制到用户界面上
   - 网络资源的管理、下载等
2. 第三方插件进程  
   每种类型的插件对应一个进程，仅当使用该插件时才创建
3. GPU 进程  
   最多一个，用于 3D 绘制等
4. 浏览器渲染进程  
   浏览器内核，Renderer 进程，内部是多线程的
   默认每个 Tab 页面一个进程，互不影响，主要作用是：
   - 页面渲染，脚本执行，事件处理等

## 浏览器多进程的优势

相对于单进程浏览器，多进程有如下优点：

- 避免单个 page crash 影响整个浏览器
- 避免第三方插件 crash 影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

## 浏览器内核（渲染进程）

对于普通的前端操作来说，最重要的是“渲染进程”：页面的渲染、JS 的执行、事件的循环都在这个进程内进行。  
**浏览器的渲染进程是多线程的**

### 常驻线程

1. GUI 渲染线程
   - 负责渲染浏览器界面，解析 HTMl、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等
   - 当界面需要重绘（repaint）或由于某种操作引发回流（reflow）时，该线程就会执行
   - **GUI 渲染线程与 JS 引擎线程是互斥的**,当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中 **等到 JS 引擎空闲时** 立即被执行
2. JS 引擎线程
   - 也称为 JS 内核，负责处理 JS 脚本程序（如 V8 引擎）
   - JS 引擎线程负责解析 JS 脚本，运行代码
   - JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只由一个 JS 线程在运行 JS 程序
   - **GUI 渲染线程与 JS 引擎线程是互斥的** ,所以如果 JS 执行的时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞
3. 事件触发线程
   - 归属于浏览器而不是 JS 引擎，用来控制事件循环  
     可以理解，毕竟 JS 引擎自己都忙不过来，需要浏览器另开线程协助
   - 当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其它线程，如鼠标点击、Ajax 异步请求等）， 会将对应任务添加到事件线程中
   - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
   - 由于 JS 的单线程关系，这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）
4. 定时触发器线程
   - setInterval 与 setTimeout 所在线程
   - 浏览器定时计数器并不是由 JS 引擎计数的，（因为 JS 引擎是单线程的,如果处于阻塞线程状态就会影响计时的准确）
   - 通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
   - W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms
5. 异步 http 请求线程
   - XMLHttpRequest 在链接后是通过浏览器新开一个线程请求
   - 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JS 引擎执行

### 浏览器内核中线程之间的关系

1. GUI 渲染线程与 JS 引擎线程互斥  
   由于 JS 是可以操作 DOM 的，如果在修改这些元素属性的同事渲染界面（即 JS 线程与 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致  
   因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程和 JS 引擎为互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行
2. JS 阻塞页面加载
   JS 如果执行时间过长就会阻塞页面  
   假如 JS 引擎正在进行巨量的计算，此时就算 GUI 有更新，也会被保存到队列中，等待 JS 引擎空闲后执行。然后由于巨量计算，故 JS 引擎很可能很久后才能空闲，自然会感觉巨卡  
   所以，要尽量避免 JS 执行时间过长，因为它会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉
3.
