# 前置篇

## 内存

let s = "hello world".to_string();

只读数据段(RODATA)  
堆上的数据大小不确定且可以增长，我们需要知道它的长度和目前大小  
为表述这个字符串，我们使用三个 word：第一个表示指针、第二个表示字符串当前长度（11）、第三个表示这片内存的总容量（11）。在 64 位系统下，三个 word 是 24 个字节

### 栈

栈是程序运行的基础。每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧（frame）

一个程序的调用栈最底部，除去入口帧（entry frame），就是 main 函数对象的帧，而随着 main()函数一层层的调用，栈会一层层扩展；调用结束，栈又会一层层回溯，把内存释放回去。

在调用过程中，一个新的帧会分配足够的空间存储寄存器的上下文。在函数里使用到的通用寄存器会在栈中保存一个副本，当这个函数调用结束，通过副本，可以恢复出原来的寄存器的上下文，就像什么都没有经历一样。此外，函数所需要使用到的局部变量，也都会在帧分配的时候被预留出来

一个函数运行时，如何确定究竟需要多大的帧呢？  
这要归功于编译器。在编译并优化代码的时候，一个函数就是一个最小的编译单元

在这个函数里，编译器得知道要用到哪些寄存器、栈上要放哪些局部变量，而这些都要在编译时确定。所以编译器就需要明确每个局部变量的大小，以便于预留空间

**在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全放在栈上，最好放在堆上**

放栈上的问题

栈上的内存分配非常高效。只需要改动栈指针（stack pointer)，就可以预留相应的空间；把栈指针改动回来，预留的空间又会被释放掉。预留和释放只是动动寄存器，不涉及额外计算、不涉及系统调用，因此效率很高

实际工作中，又要避免把大量数据分配在栈上  
**这主要考虑到调用栈的大小，避免栈溢出（stack overflow)**。一旦当前程序的调用栈超出了系统允许的最大栈空间，无法创建新的帧，来运行下一个要执行的函数，就会发生栈溢出，这时程序会被系统终止，产生崩溃信息

过大的栈内存分配是导致栈溢出的原因之一，更广为人知的原因是递归函数没有妥善终止。一个递归函数不断调用自己，每次调用都会形成一个新的帧，如果递归函数无法终止，最终就会导致栈溢出

### 堆

栈虽然很高效，但它的局限也显而易见。当我们需要动态大小的内存时，只能使用堆，比如可变长度的数组、列表、哈希表、字典，它们都分配在堆上

堆上分配内存时，一般都会预留一些空间，这是最佳实践。这是因为堆上内存分配会使用 libc 提供的 malloc()函数，其内部会请求操作系统的系统调用，来分配内存。系统调用的代价是昂贵的，所以我们要避免频繁地 malloc

除了动态大小的内存需要被分配到堆上外，动态生命周期的内存也需要分配到堆上

栈上的内存在函数调用结束之后，所使用的的帧被回收，相关变量对应的内存也都被回收。所以栈上内存的生命周期是不受开发者控制的，并且局限在当前调用栈。

而堆上分配出来的每一块内存都需要显式的释放，这就使堆上内存有更灵活的生命周期，可以在不同的调用栈之间共享数据

**放堆上的问题**

如果手工管理堆内存的话，堆上内存分配后忘记释放，就会造成内存泄露。一旦有内存泄露，程序运行的越久，就越吃内存，最终会因为占满内存而被 OS 终止运行

如果堆上内存被多个线程的调用栈引用，该内存的改动要特别小心，需要加锁以独占访问，来避免潜在问题。比如说，一个线程在遍历列表，而另一个线程在释放列表中的某一项，就可能访问到野指针，导致堆越界（heap out of bounds)。堆越界是第一大内存安全问题

如果堆上内存被释放，但栈上指向内存的相应指针没有被清空，就有可能发生使用已释放内存（use after free）的情况，程序轻则崩溃，重则隐含安全隐患，根据微软安全反应中心的研究，这是第二大内存安全问题

### GC、ARC 如何解决

为避免内存手动管理造成的这些问题，以 Java 为首的一系列编程语言，采用了追踪式垃圾回收的方法（Tracing GC），来自动管理堆内存。这种方式通过定期标记（mark）找出不再被引用的对象，然后将其清理（sweep)掉，来自动管理内存，减轻开发者的负担。

而 ObjC 和 Swift 则走了另一条路：自动引用计数（Automatic Reference Counting)。在编译时，它为每个函数插入 retain/release 语句来自动维护堆上对象的引用计数，当引用计数为 0 的时候，release 语句就释放对象

**方案对比**

从效率上来说，GC 在内存分配和释放上无需额外操作， 而 ARC 添加了大量的额外代码处理引用计数，所以 GC 效率更高，吞吐量（throughput)更大

但是，GC 释放内存的时机是不确定的，释放时引发的 STW(stop the world)，也会导致代码执行的延迟（latency)不确定。所以一般携带 GC 的编程语言，不适于做嵌入式系统或者实时系统。当然，Erlang VM 是个例外，它把 GC 的粒度下放到每个 process，最大程度解决了 STW 的问题

我们使用 Android 手机偶尔感觉卡顿，而 iOS 手机却运行丝滑，大多也是这个原因。而且做后端服务时，API 或者服务响应时间的 p99（99th percentile)也会受到 GC STW 的影响而表现不佳

GC 分配和释放内存的效率和吞吐量要比 ARC 高，但因为偶尔的高延迟，导致被感知的性能比较差，故会给人一种 GC 不如 ARC 性能好的感觉

### 总结

对于存入栈上的值，它的大小在编译时就需要确定。栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用

堆可以存入大小未知或者动态伸缩的数据类型。堆上存储的变量，其声明周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用。但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论 GC 还是 ARC，都有性能损耗和其它问题

**一句话对比总结**:栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期

## 基本概念
