# 第一部分 作用域和闭包

## 第一章 作用域是什么

几乎所有语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个值进行访问和修改。事实上，正是这种储存和访问变量的值的能力，将 **_状态_** 带给了程序。

几个问题：  
 变量储存在哪里？
程序如何找到它们？

这些问题说明需要一套设计良好的规则来存储变量，并且在之后可以方便的找到这些变量。这套规则被称为作用域。

### 1.1 编译原理

JavaScript 实际上是一门编译语言。它不是提前编译的，编译结果也不能在分布式系统中进行移植。

传统编译步骤：

1. 分词/词法分析（Tokenizing/Lexing)  
   这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为 **_词法单元（token）_**。举个例子:
   ```js
   var a = 2;
   ```
   这段程序会被分解为下面这些词法单元：var、a、=、2、；。空格是否会被当做词法单元，取决于空格在这门语言中是否具有意义。
2. 解析/语法分析（Parsing）  
   这个过程是将词法单元流（数组）转换为一个由元素逐级嵌套所组成的程序语法结构树。这棵树被称为**抽象语法树** (Abstract Syntax Tree, AST)。  
   var a = 2 ;的抽象语法树中可能会有一个叫做 VariableDeclaration 的顶级节点，接下来是一个 Identifier(值为 a)的子节点，以及一个叫做 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫做 NumbericLiteral（值为 2）的子节点。
3. 代码生成  
   将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等信息相关。  
   抛开具体细节，简单来说就是有某种方法可以将 var a = 2;的 AST 转化为一组机器指令，用来创建一个叫做 a 的变量(包含分配内存等)，并将一个值储存在 a 中。

JavaScript 引擎不会有大量的时间来进行优化，因为与其它语言不同，JavaScript 的编译过程不是发生在构建之前的。

对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。在作用域的背后，JavaScript 用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能最佳。

任何 JavaScript 代码片段在执行前都要进行编译。

### 1.2 理解作用域

以以下代码为例：

```js
var a = 2;
```

#### 1.2.1 演员表

- 引擎  
  从头到尾负责整个 JavaScript 程序的编译及执行过程
- 编译器  
  负责语法分析及代码生成等脏活累活
- 作用域  
  负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

#### 1.2.2 对话

引擎会认为示例代码中有两个完全不同的声明：

1.  一个由编译器在编译时处理
2.  另一个由引擎在运行时处理

具体的处理过程

1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a
2. 接下来编译器会为引擎生成运行时需要的代码，这些代码被用来处理 a=2 这个赋值操作。引擎运行时会首先询问作用域，在当前作用域集合中是否存在一个叫做 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量
3. 如果引擎找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常

总结

```
变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过的话），然后在运行时引擎会在作用域中查找该变量，如果能找到就会对它赋值。
```

#### 1.2.3 编译器有话说

编译器生成代码，引擎执行它时，会通过查找变量 a 来判断它是否已经声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。  
 示例中，引擎会为变量 a 进行 LHS 查询。另一个查找类型叫做 RHS  
 当变量出现在**_赋值操作_**的左侧时进行 LHS 查询，出现在右侧进行 RHS 查询；更准确一点，RHS 查询与简单的查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其进行赋值。从这个角度来说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确的说是“非左侧“。  
 可以将 RHS 理解为“retrieve his source value”（取到它的源值），这意味着“得到 xx 的值”。

LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定以为着就是“=赋值操作符的左侧或右侧”。赋值操作还有其它几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS)”以及“谁是赋值操作的源头（RHS）”

#### 1.2.4 引擎和作用域的对话

示例程序:

```js
function foo(a) {
  console.log(a);
}

foo(2);
```

处理过程描述：

```
引擎：我说作用域，我需要为foo进行RHS引用，你见过它吗？
作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你
引擎：太够意思了！好吧，我来执行一下foo
引擎：作用域，还有个事儿。我需要为a进行LHS引用，这个你见过吗？
作用域：这个也见过，编译器最近把它声明为foo的一个形式参数了，拿去吧
引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给它
引擎：哥们，不好意思又来打扰你。我要为console进行RHS引用，你见过它吗
作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console是个内置对象，给你
引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数
引擎：哥们，能帮我再找一下对a的RHS引用吗？虽然我记得它，但想再确认一次
作用域：放心吧，这个变量没有变动过，拿走，不谢
引擎：真棒。我来把a的值，也就是2，传递进log(..)
...
```

### 1.3 作用域嵌套

作用域是根据名称查找变量的一套规则。当一个块或者函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。  
示例代码：

```js
function foo(a) {
  console.log(a + b);
}
var b = 2;
foo(2);
```

对 b 的访问过程：

```
引擎：foo的作用域兄弟，你见过b吗，我需要对它进行RHS引用
作用域：听都没听过，走开
引擎：foo的上级作用域兄弟，咦，有眼不识泰山，原来是全局作用域大哥。你见过b吗，我需要对它进行RHS引用
作用域：当然了，给你
```

遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

### 1.4 异常

为什么区分 LHS 和 RHS 是一件重要的事情呢？

因为在变量还没有声明（在任何作用域中都无法找到该变量）到的情况下，这两种查询的行为是不一样的。

示例代码

```js
function foo(a) {
  console.log(a + b);
}

foo(2);
```

第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。如果 RHS 查询所在的嵌套作用域中遍寻不到所需要的变量，引擎就会抛出 ReferenceError 异常。  
当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在“非严格模式”下。
接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值的属性，那么引擎就会抛出另外一种类型的异常：TypeError

ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

### 1.5 小结

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。=操作符或调用函数时传入参数的操作都回导致关联作用域的赋值操作。

JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解为两个独立的步骤：

1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前执行
2. 接下来，a=2 会查询（LHS）变量 a 并对其进行赋值

LHS 和 RHS 查询都回在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论是否能找到都将停止。

不成功的 RHS 引用会导致 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError（严格模式下）

## 第二章 词法作用域

我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

作用域共有两种主要的工作模式：

1. 第一种是最为普遍的，被大多数编程语言所采用的的词法作用域
2. 第二种是动态作用域，仍有一些编程语言在使用（如 Bash 脚本、perl 中的一些模式等）

### 2.1 词法阶段

大部分标准语言编译器的第一个工作阶段叫做词法化。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

这个概念是理解此法作用域及其名称来历的基础。

**_词法作用域就是定义在词法阶段的作用域_**。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，因此当词法分析器处理代码时会保持作用域不变（大多数情况下如此）。

有一些方法能欺骗词法作用域，这些方法在词法分析器处理过后依然可以修改作用域。事实上，**_让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践_**。

作用域气泡是由其对应的作用域块代码写在哪里决定，它们是逐层包含的。

查找  
作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

**_作用域查找会在找到第一个匹配的标识符时停止_** 。在多层的嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应"(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应，作用域查找始终从运行时所处的最内层作用域开始，逐级向外或者说向上进行，知道遇见第一个匹配的标识符为止。

全局变量会自动成为全局对象（比如浏览器的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是直接通过对全局对象属性的引用来对其进行访问：window.a，通过这种技术可以访问那些被同名变量所屏蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

**_词法作用域只会查找一级标识符_**。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，**_对象属性访问规则_**会分别接管对 bar 和 baz 属性的访问。

### 2.2 欺骗词法

JavaScript 中有两种机制来实现在运行时修改词法作用域的目的。社区普遍认为这不是啥好主意，因为：**_欺骗词法作用域会导致性能下降_**。

不推荐使用 eval 和 with 的原因：

1. 欺骗词法作用域会导致性能下降
2. eval 和 with 会被严格模式所影响

#### 2.2.1 eval

JavaScript 中的 eval(..)函数可以接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。

在执行 eval 之后的代码时，引擎并不知道前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

默认情况下，如果 eval 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval 所处的词法作用域进行修改。

```js
function foo(str, a) {
  eval(str); //欺骗
  console.log(a, b);
}

var b = 2;
foo('var b = 3;', 1); //1, 3
```

在严格模式的程序中，eval 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

```js
function foo(str) {
  'use strict';
  eval(str);
  console.log(a); // ReferenceError: a is not defined
}

foo('var a  = 2;');
```

JavaScript 中还有其它一些 function 效果与 eval 类似。setTimeout 和 setInterval 的第一个参数可以是字符串，字符串的内容可以被截石位一段动态生成的函数代码。这些功能已经过时且不被提倡。**_不要使用它们_**。

#### 2.2.2 with

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

```js
var obj = {
  a: 1,
  b: 2,
  c: 3,
};
// 单调乏味的重复obj
obj.a = 2;
obj.b = 3;
obj.c = 4;

// 简单的快捷方式
with (obj) {
  a = 2;
  b = 3;
  c = 4;
}
```

但实际上这不仅仅是为了方便的访问对象属性，考虑如下代码：

```js
function foo(obj) {
  with (obj) {
    a = 2;
  }
}

var o1 = {
  a: 3,
};

var o2 = {
  b: 3,
};
foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2-不好，a被泄漏到全局作用域了
```

可以这样理解：当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中刚并没有 a 标识符，因此进行了正常的 LHS 标识符查找。  
o2 的作用域、foo 的作用域和全局作用域中都没有找到标识符 a，因此当 a = 2 执行时，自动创建了一个全局变量

with 可以将一个没有或者有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符

尽管 with 块可以将一个对象处理为词法作用域，但是这个块内正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中

eval 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域；而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域

#### 2.2.3 性能

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。  
但如果引擎在代码中发现了 eval 和 with，它只能简单假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象内容到底是什么  
最悲观的情况是如果出现了 eval 和 with， 所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化

### 2.3 小结

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

JavaScript 中有两个机制可以欺骗词法作用域：eval 和 with。前者可以对一段包含一个或多个声明的代码字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用单做作用域来处理，将对象的属性当做作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）
这两个机制的副作用是引擎无法在编译时对作用于进行优化，因此引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。**_不要使用它们_**。

## 第三章 函数作用域和块作用域

作用域包含了一系列的“气泡”，每一个都可以作为容器，其中包含了标识符（变量、函数）的定义。这些气泡互相嵌套并且整齐排列成蜂窝型，排列的结果是写在代码时定义的。

### 3.1 函数中的作用域

JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个作用域气泡。

函数作用域的含义是指：属于这个函数的全部变量都可以在整个函数的范围内使用及复用（在嵌套的作用域中也是如此）。这种设计方案能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。

### 3.2 隐藏内部实现

可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。

很多原因促成了基于作用域的隐藏方法。它们大都引申自最小特权原则，也叫最小授权和最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容。

**_规避冲突_**  
“隐藏”作用域中的变量和函数所带来的的另一个好处，是可以避免同名标识符之间的冲突。

1. 全局命名空间
   变量冲突的一个典型的栗子存在于全局作用域中。当程序中加载了多个第三方库，如果他们没有妥善地将内部私有的函数和变量隐藏起来，就会很容易引发冲突。  
   这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的“命名空间”，所有需要暴露给外界的功能都会成为这个对象的属性，而不是将自己的标识符直接暴露在顶级的词法作用域中。
   ```js
   var myReallyCoolLib = {
     awesome: 'stuff',
     doSomething: function () {
       // ...
     },
     doAnotherThing: function () {
       // ...
     },
   };
   ```
2. 模块管理
   另一种规避冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。这是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。

### 3.3 函数作用域

在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。这将导致一些问题

1. 必须声明一个具名函数，如 foo，foo 这个名称本身“污染”了所在作用域
2. 必须显式通过函数名调用这个函数才能运行其中的代码

如果函数不需要函数名，并且能够自动运行，这将会更加理想。

```js
var a = 2;
(function foo() {
  //<--添加这一行
  var a = 3;
  console.log(a);
})(); // <--以及这一行
console.log(a);
```

区分函数声明和表达式的最简单的方法就是看 function 关键字出现在声明的位置。如果 function 是声明中的第一个词，那就就是一个函数声明，否则就是一个函数表达式。

函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。

(function foo(){...})作为函数表达式意味着 foo 只能在...所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。

#### 3.3.1 匿名和具名

函数表达式可以是匿名的（匿名函数表达式）；而函数声明则不可以省略函数名

匿名函数表达式的缺点：

1. 匿名函数在追踪栈中不会显示出有意义的函数名，调试困难
2. 没有函数名，函数需要引用自身时只能用过期的 arguments.callee 引用
3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明

始终给函数表达式命名是一个最佳实践。

```js
setTimeout(function timeoutHandler() {
  console.log('I want 1 second');
}, 1000);
```

#### 3.3.2 立即执行函数表达式（Immediately Invoked Function Expression，IIFE)

```js
var a = 2;
(function foo() {
  var a = 20;
  console.log(a);
})();
console.log(a);
```

IIFE 的两种写法

1. (function xx(){..})()
2. (function(){..}())

## 第四章 提升

任何声明在某个作用域内的变量，都将附属于这个作用域。  

包含变量和函数在内的所有声明都会在任何代码被执行前首先执行（在编译阶段）。这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程叫做提升。  

只有声明本身会被提升，而赋值及其它运行逻辑会留在原地。  

每个作用域都会进行提升操作。  

即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。  

函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。

## 第五章 作用域闭包

JavaScript 中闭包无处不在，你只需要能够识别并拥抱它。

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

一下代码展示了闭包：

```js
function foo() {
  var a = 3;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo();
baz(); // 2 - 这就是闭包的效果
```

在 foo()执行后，通常会期待 foo()的整个内部作用域被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。

谁在使用这个作用域？原来是 bar()本身在使用。拜 bar()声明的位置所赐，它拥有涵盖 foo()内部的作用域的闭包，使得该作用域能够一直存活，以供 bar()在之后任何时间进行引用。

bar()依然持有对该作用域的引用，而这个引用就叫做闭包。

无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。

```js
function foo() {
  var a = 2;

  function baz() {
    console.log(a);
  }
  bar(baz);
}

function bar(fn) {
  fn(); // 闭包
}
```

无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

### 5.3 现在我懂了

```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 100);
}
wait('hello, closure');
```

将内部函数 timer 传递给 setTimeout。timer 具有涵盖 wait 作用域的闭包，因此还保有对变量 message 的引用。wait 执行 100 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait 作用域的闭包。

深入到引擎的内部原理中，内置的工具函数 setTimeout 持有一个对参数的引用，这个参数也许叫 fn 或 func 等。引擎会调用这个函数，本例中就是 timer，而词法作用域在这个过程中保持完整。

这就是闭包。

### 5.4 循环和闭包

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

代码在运行时会以每秒一次的频率输出 5 个 6。（尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际只有一个 i）

我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。之前说过 IIFE 会通过声明并立即执行一个函数来创建作用域：

```js
for (var i = 1; i <= 5; i++) {
  (function () {
    setTimeout(function timer() {
      console.log(i);
    }, i * 1000);
  })();
}
```

代码在运行时会以每秒一次的频率输出 5 个 6。（我们确实拥有了更多词法作用域：每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。但如果作用域是空的，那么仅仅将它们进行封闭是不够的。）

IIFE 只是一个什么都没有的空作用域。它需要有自己的变量，用来在每个迭代中存储 i 值

```js
for (var i = 1; i <= 5; i++) {
  (function () {
    setTimeout(function timer() {
      var j = i;
      console.log(j);
    }, j * 1000);
  })();
}
```

可以正常工作了，再改进下：

```js
for (var i = 1; i <= 5; i++) {
  (function (j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

在迭代内部使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内，每个迭代中都会含有一个具有正确值的变量供我们访问。

重返块作用域

```js
for (var i = 1; i <= 5; i++) {
  let j = i; // 闭包的块作用域
  setTimeout(function timer() {
    console.log(j);
  }, j * 1000);
}
```

更进一步：

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

### 5.5 模块

```js
function foo() {
  var something = 'cool';
  var another = [1, 2, 3];

  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join('!'));
  }
}
```

如上，这里没有明显的闭包，只有两个私有变量 something 和 another，以及 doSomething()和 doAnother()两个内部函数，它们的词法作用域（而这就是闭包）也就是 foo()的内部作用域。

```js
function CoolModule() {
  var something = 'cool';
  var another = [1, 2, 3];

  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join('!'));
  }
  return {
    doSomething: doSomething,
    doAnother: doAnother,
  };
}

var foo = CoolModule();
foo.doSomething(); // cool
foo.doAnother(); // 1!2!3
```

这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为*模块暴露*。
研究一下这些代码：

1. CoolModule()只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。
2. CoolModule()返回一个用对象字面量{key:value, ...}来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API

从模块返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery 和$标识符就是 jQuery 模块的公共 API，但它们本身都是函数。

模块模式需要具备两个必要条件：

1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

简单的单例模式：

```js
var foo = (function CoolModule() {
  var sth = 'cool';
  var another = [1, 2, 3];
  function doSth() {
    console.log(sth);
  }
  function doAnother() {
    console.log(anther.join('!'));
  }

  return {
    doSth: doSth,
    doAnother: doAnother,
  };
})();

foo.doSth();
foo.doAnother();
```

将模块函数转换成 IIEF，立即调用这个函数并将返回值直接赋值给单例的模块实例标识符 foo。

模块也是函数，也可以传递参数。

可以在模块中命名将要作为公共 API 返回的对象。通过在模块实例的内部保留对公共对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。

#### 5.5.1 现代的模块机制

大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的 API。

模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。

#### 5.5.2 未来的模块机制

ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当做独立的模块来处理。每个模块都可以导入其它模块或特定 API 成员，同样也可以导出自己的 API 成员。

基于函数的模块并不是一个能够被稳定识别的模式（编译器无法识别），它们的 API 语义只有在于小宁时才会被考虑进来。因此可以在运行时修改一个模块的 API。  
ES6 模块更加稳定(API 不会在运行时改变)。由于编辑器知道这一点，因此会在编译期检查对导入模块的 API 成员的引用是否真是存在。如果 API 引用并不存在，编译器会在运行时抛出一个或多个“早期“错误。

ES6 的模块没有“行内”格式，必须被定义在独立的文件中（一个文件一个模块）。浏览器或引擎有一个默认的“模块加载器”可以在导入模块时异步地加载模块文件。
bar.js

```js
function hello(who) {
  return 'let me introdule:' + who;
}
export { hello };
```

foo.js

```js
// 仅从“bar”模块导入hello()
import hello from 'bar';

var hungry = 'hippo';
function awesome() {
  console.log(hello(hungry));
}
export { awesome };
```

baz.js

```js
// 导入完整的foo和bar模块
import { foo } from 'foo';
import { bar } from 'bar';

console.log(bar.hello('rhino')); // let me introduce: rhino
foo.awesome(); //let me introduce: hippo
```

import 可以将一个模块中的一个或多个 API 导入到当前的作用域中，并分别绑定在一个变量上。export 会将当前模块的一个标识符（变量、函数）导出为公共 APi。这些操作可以在模块定义中根据需要使用任意多次。

模块文件中的内容会被当作好像在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。

### 5.6 小结

当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。

模块有 2 个主要特征

1. 为创建内部作用域而调用了一个包装函数
2. 包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包

# 第二部分 this 和对象原型

## 第一章 关于 this

this 关键字是 JavaScript 中最复杂的机制之一。

### 1.1 为什么要用 this

this 提供了一种更优雅的方式来隐藏“传递”一个对象引用，因此可以将 API 设计的更加简洁且易于复用。

### 1.2 误解

#### 1.2.1 指向自身

人们很容易把 this 错误理解成指向函数自身。

#### 1.2.2 它的作用域

第二种常见误解是：this 指向函数的作用域。问题有点复杂，在某些情况下它是正确的，有些情况下它是错误的。

需要明确的是： this 在任何情况下都不指向函数的词法作用域。  
在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。

每当你想要把 this 和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。

### 1.3 this 到底是什么

this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

当一个函数被调用时，会创建一个活动记录（也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。

### 1.4 小结

this 很重要。

this 既不指向函数自身，也不指向函数的词法作用域

this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。

## 第二章 this 全面解析

### 2.1 调用位置

调用位置就是函数在代码中被调用的位置（而不是声明的位置）

最重要的是分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。  
举个例子：

```js
function baz() {
  // 当前调用栈：baz
  // 因此，当前调用位置是全局作用域

  console.log('baz');
  bar(); // <-- bar的调用位置
}

function bar() {
  // 当前调用栈是：baz->bar
  // 因此，当前调用位置是：baz
  console.log('bar');
  foo(); //<-- foo的调用位置
}

function foo() {
  // 当前调用栈是：baz->bar->foo
  // 因此，当前调用位置在bar中
  console.log('foo');
}
baz(); // <-- baz的调用位置
```

注意我们是如何从调用栈中分析出真正的调用位置的，因为它决定了 this 的绑定。

如果想要分析 this 的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。

### 2.2 绑定规则

#### 2.2.1 默认绑定

最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其它规则时的默认规则。

```js
function foo() {
  console.log(this.a);
}
var a = 2;
foo();
```

foo 函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。

虽然 this 的绑定规则完全取决于调用位置，但是只有函数运行在非 strict mode 下时，默认绑定才能绑定到全局对象；严格模式下与 foo()的调用位置无关

#### 2.2.2 隐式绑定

#### 2.2.3 显示绑定

#### 2.2.4 new 绑定

另一条需要考虑的规则是调用位置是否有上下文对象，或者而说是否被某个对象拥有或包含

```js
function foo() {
  console.log(this.a);
}
var obj = {
  a: 2,
  foo: foo,
};
obj.foo();
```

调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有“或者”包含“它

对象属性引用链中只有最后一层会影响调用位置：

```js
function foo() {
  console.log(this.a);
}
var obj2 = {
  a: 42,
  foo: foo,
};
var obj1 = {
  a: 'obj1',
  obj2: obj2,
};
obj1.obj2.foo(); // 42
```

隐式丢失：一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或 undefined 上，取决于是否是严格模式

### 2.3 优先级

你必须找到调用位置，然后判断需要应用哪条规则。

判断 this-可以按照一下顺序来进行判断

1. 函数是否在 new 中调用（new 绑定）？如果是的话，this 绑定的是新创建的对象  
   var bar = new foo();
2. 函数是否通过 call、apply（显示绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象  
   var bar = foo.call(obj);
3. 函数是否在某个上下文对象中调用（隐式调用）？如果是的话，this 绑定的是哪个上下文对象  
   var bar= obj.foo();
4. 如果都不是的话，使用默认绑定。如果在严格模式下就绑定到 undefined，否则绑定到全局对象  
   var bar = foo();

### 2.4 绑定例外

某些场景下 this 的绑定行为会出乎意料。

#### 2.4.1 被忽略的 this

如果把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则

Object.create(null)和{}很像，但是并不会创建 Object.prototype 这个委托，所以它比{}更空。故可以用该对象替换传给 call 和 apply 的 null 或 undefined

#### 2.4.2 间接引用

你有可能创建一个函数的“间接引用”，在这种情况下，调用干这个函数会应用默认绑定规则。间接引用最容易在赋值时发生：

```js
function foo() {
  console.log(this.a);
}
var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
(p.foo = o.foo)(); // 浏览器中:2  Node中：undefined
```

#### 2.4.3 软绑定

硬绑定可以把 this 绑定到指定的对象（除了使用 new 时），防止函数调用应用默认绑定规则。问题在于：硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或显式绑定来修改 this

如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或显式绑定修改 this 的能力

```js
if (Function.prototype.softBind) {
  Function.prototype.softBind = function (obj) {
    var fn = this;
    // 捕获所有curried参数
    var curried = [].slice.call(arguments, 1);
    var bound = function () {
      return fn.apply(!this || this === (window || global) ? obj : this, curried.concat.apply(curried, arguments));
    };
    bound.prototype = Object.create(fn.prototype);
    return bound;
  };
}
```

### 2.5 this 词法

ES6 中有一种无法使用以上规则的特殊函数类型：箭头函数

箭头函数并不是使用 function 关键字定义的，而是使用=>操作符定义的。箭头函数不使用 this 的四种表中规则，而是根据外层（函数或者全局）作用域来决定 this。

我们来看看箭头函数的词法作用域：

```js
function foo() {
  // 返回一个箭头函数
  return (a) => {
    // this继承自foo()
    console.log(this.a);
  };
}
var obj1 = { a: 2 };
var obj2 = { a: 3 };

var bar = foo.call(obj1);
bar.call(obj2); // 2
```

foo()内部创建的箭头函数会捕获调用时 foo()的 this。由于 foo()的 this 绑定到 obj1，bar 的 this 也会绑定到 obj1,箭头函数的绑定无法被修改（new 也不行）

### 2.6 小结

如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面四条规则来判断 this 的绑定对象：

1. 由 new 调用？绑定到新创建的对象
2. 由 call、apply 调用？绑定到上下文对象
3. 由上下文对象调用个？绑定到上下文对象
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象

一定要注意：有些调用可能无意中使用默认绑定规则。如果想“更安全”忽略 this 绑定，你可以使用一个 DMZ 对象，就是 Object.create(null)，以保护全局对象

ES6 的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说：箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。

## 第三章 对象

## 第四章 混合对象“类”

## 第五章 原型

## 第六章 行为委托
